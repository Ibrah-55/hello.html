<!DOCTYPE html>
<html>
    <head>
        <title>https://ibrahjarvis/programminglanguages...</title>
    </head>
    <body>
       <h5>Below are some common programming languages to learn</h5>
       <ul>
          <li>Python</li>
          It’s an easy language that just about anyone can master in a short period of time. If you’re impatient and want to make quick scripts that deliver results (and you don’t mind very rudimentary debugging), then you should definitely explore it! 
          See python documentation here
          <a href="https://docs.python.org/"> Python3 Documentation </a>
          <li><a href="https://devdocs.io/javascript/">Javascipt</a></li>
          JavaScript is a good representative of the semantic model popular in dynamic, higher-order languages such as Python, Ruby and Perl.As the native language of the web, its pragmatic advantages are unique.
          <li><a href="https://docs.oracle.com/en/java/">Java</a></li>
          The primary advantage of Java application development is that it is free and its syntax bears resemblance to various C-based programming languages, making it easier for developers to understand and implement.
          <li><a href="https://devdocs.io/c/">C</a></li>
          If you want to be able to do more than write a simple web app, C is a great language. If you want to write a great, fast game, C is again a great choice. You can write an entire OS in C.
          <li><a href="https://devdocs.io/cpp/">C++</a></li>
          You can tap directly into the Windows API and work magic with it. You can program with objects and classes or abandon them altogether and make a C-style structured program.
          <li><a href="https://www.postgresql.org/docs/9.3/sql.html">SQl<a/></li>
          SQL is everywhere, and I'm not saying that because I want you to use it. It's just a fact. I bet you have some in your pocket right now. All Android Phones and iPhones have easy access to a SQL database called SQLite and many applications on your phone use it directly. It runs banks, hospitals, universities, governments, small businesses, large ones, just about every computer and every person on the planet eventually touches something running SQL. SQL is an incredibly successful and solid technology.

       </ul>
       Below is a presentation on the Best programming languages to learn.
          <a href="https://youtu.be/U1PVd9ZN59E" target="_blank">Computer Science</a>
          <p>
           <button><a class="primary" href="Best Programming Languages to Learn.odp" target="_blank">Download Presentation <span class="glyphicon glyphicon-chevron-right"></span></a> </button>
</p>
 <h5>What every computer SCientist should know</h5>
        <ul>
                <li>Portfolio versus Resume
                    <ul>
                        <li>A resume says nothing of a programmer's ability. Every computer science major should build a portfolio.
A portfolio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code (hosted perhaps on github or Google code). Contributions to open source should be linked and documented. A code portfolio allows employers to directly judge ability. GPAs and resumes do not.</li><br>
                    </ul>
                </li>

                <li>Programming languages
                    <ul>
                        <li>Programming languages rise and fall with the solar cycle. A programmer's career should not. While it is important to teach languages relevant to employers, it is equally important that students learn how to teach themselves new languages. The best way to learn how to learn programming languages is to learn multiple programming languages and programming paradigms. The difficulty of learning the nth language is half the difficulty of the (n-1)th. Yet, to truly understand programming languages, one must implement one. Ideally, every computer science major would take a compilers class. At a minimum, every computer science major should implement an interpreter.</li><br>
                    </ul>
                </li>

                <li>Discrete mathematics
                    <ul>
                        <li>Students must have a solid grasp of formal logic and of proof. Proof by algebraic manipulation and by natural deduction engages the reasoning common to routine programming tasks. Proof by induction engages the reasoning used in the construction of recursive functions. Students must be fluent in formal mathematical notation, and in reasoning rigorously about the basic discrete structures: sets, tuples, sequences, functions and power sets.</li><br>
                    </ul>
                </li>

                <li>Data structures and algorithms
                    <ul>
                        <li>Students should certainly see the common (or rare yet unreasonably effective) data structures and algorithms. But, more important than knowing a specific algorithm or data structure (which is usually easy enough to look up), students must understand how to design algorithms (e.g., greedy, dynamic strategies) and how to span the gap between an algorithm in the ideal and the nitty-gritty of its implementation.</li><br>
                    </ul>
                </li>

                <li>Theory
                    <ul>
                        <li>A grasp of theory is a prerequisite to research in graduate school.
Theory is invaluable when it provides hard boundaries on a problem (or when it provides a means of circumventing what initially appear to be hard boundaries).
Computational complexity can legitimately claim to be one of the few truly predictive theories in all of computer "science." A computer student must know where the boundaries of tractability and computability lie. To ignore these limits invites frustration in the best case, and failure in the worst.</li><br>
                    </ul>
                </li>

                <li>Architecture
                    <ul>
                        <li>There is no substitute for a solid understanding of computer architecture. Everyone should understand a computer from the transistors up. The understanding of architecture should encompass the standard levels of abstraction: transistors, gates, adders, muxes, flip flops, ALUs, control units, caches and RAM. An understanding of the GPU model of high-performance computing will be important for the foreseeable future.</li><br>
                    </ul>
                </li>

                <li>Operating systems
                    <ul>
                        <li>Any sufficiently large program eventually becomes an operating system.
As such, a person should be aware of how kernels handle system calls, paging, scheduling, context-switching, filesystems and internal resource management.
A good understanding of operating systems is secondary only to an understanding of compilers and architecture for achieving performance. Understanding operating systems (which I would interpret liberally to include runtime systems) becomes especially important when programming an embedded system without one.</li><br>
                    </ul>
                </li>

                <li>Networking
                    <ul>
                        <li>Given the ubiquity of networks, a person should have a firm understanding of the network stack and routing protocols within a network. The mechanics of building an efficient, reliable transmission protocol (like TCP) on top of an unreliable transmission protocol (like IP) should not be magic to a computer guy. It should be core knowledge. People must understand the trade-offs involved in protocol design--for example, when to choose TCP and when to choose UDP. (Programmers need to understand the larger social implications for congestion should they use UDP at large scales as well.)</li><br>
                    </ul>
                </li>

                <li>Security
                    <ul>
                        <li>The sad truth of security is that the majority of security vulnerabilities come from sloppy programming. The sadder truth is that many schools do a poor job of training programmers to secure their code. Developers must be aware of the means by which a program can be compromised. They need to develop a sense of defensive programming--a mind for thinking about how their own code might be attacked.
Security is the kind of training that is best distributed throughout the entire curriculum: each discipline should warn students of its native vulnerabilities.</li><br>
                    </ul>
                </li>



                <li>User experience design (UX)
                    <ul>
                        <li>Programmers too often write software for other programmers, or worse, for themselves.
User interface design (or more broadly, user experience design) might be the most underappreciated aspect of computer science. There's a misconception, even among professors, that user experience is a "soft" skill that can't be taught. In reality, modern user experience design is anchored in empirically-wrought principles from human factors engineering and industrial design. If nothing else, engineers should know that interfaces need to make the ease of executing any task proportional to the frequency of the task multiplied by its importance. As a practicality, every programmer should be comfortable with designing usable web interfaces in HTML, CSS and JavaScript.</li><br>
                    </ul>
                </li>

                <li>Software engineering
                    <ul>
                        <li>The principles in software engineering change about as fast as the programming languages do. A good, hands-on course in the practice of team software construction provides a working knowledge of the pitfalls inherent in the endeavor.
It's been recommended by several readers that students break up into teams of three, with the role of leader rotating through three different projects.
Learning how to attack and maneuver through a large existing codebase is a skill most programmers will have to master, and it's one best learned in school instead of on the job.</li><br>
                    </ul>
                </li>

                <li>Artificial intelligence
                    <ul>
                        <li>If for no other reason than its outsized impact on the early history of computing, student should study artificial intelligence. While the original dream of intelligent machines seems far off, artificial intelligence spurred a number of practical fields, such as machine learning (I really like machine learning), data mining and natural language processing.</li><br>
                    </ul>
                </li>

                <li>Databases
                    <ul>
                        <li>Databases are too common and too useful to ignore. It's useful to understand the fundamental data structures and algorithms that power a database engine, since programmers often enough reimplement a database system within a larger software system. Relational algebra and relational calculus stand out as exceptional success stories in sub-Turing models of computation. Unlike UML modeling, ER modeling seems to be a reasonable mechanism for visualing encoding the design of and constraints upon a software artifact.</li><br>
                    </ul>
                </li>
             </ul>
             <p>
<button><a href="index.html" target="_blank">HOME</a></button>
    <button>   <a href="resource.html" target="_blank">Computer Science Resources</a></button>
     <button>  <a href="use.html" target="_blank">Applications of programming languages</a></button></p>

    </body>
</html>